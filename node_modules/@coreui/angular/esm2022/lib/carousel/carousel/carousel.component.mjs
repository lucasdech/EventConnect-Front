import { Component, DestroyRef, EventEmitter, HostBinding, inject, Inject, Input, Output } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { fromEvent } from 'rxjs';
import { filter, finalize, withLatestFrom, zipWith } from 'rxjs/operators';
import { ListenersService } from '../../services';
import { ThemeDirective } from '../../shared/theme.directive';
import { CarouselState } from '../carousel-state';
import { CarouselService } from '../carousel.service';
import { CarouselConfig } from '../carousel.config';
import * as i0 from "@angular/core";
import * as i1 from "../carousel.service";
import * as i2 from "../carousel-state";
import * as i3 from "../../services";
import * as i4 from "../../shared/theme.directive";
import * as i5 from "../carousel.config";
export class CarouselComponent {
    constructor(config, hostElement, carouselService, carouselState, intersectionService, listenersService) {
        this.config = config;
        this.hostElement = hostElement;
        this.carouselService = carouselService;
        this.carouselState = carouselState;
        this.intersectionService = intersectionService;
        this.listenersService = listenersService;
        /**
         * Index of the active item.
         * @type number
         */
        this.activeIndex = 0;
        /**
         * Carousel automatically starts cycle items.
         * @type boolean
         */
        this.animate = true;
        /**
         * Carousel direction. [docs]
         * @type {'next' | 'prev'}
         */
        this.direction = 'next';
        /**
         * The amount of time to delay between automatically cycling an item. If false, carousel will not automatically cycle.
         * @type number
         * @default 0
         */
        this.interval = 0;
        /**
         * Sets which event handlers you’d like provided to your pause prop. You can specify one trigger or an array of them.
         * @type {'hover' | 'focus' | 'click'}
         */
        this.pause = 'hover';
        /**
         * Support left/right swipe interactions on touchscreen devices.
         * @type boolean
         * @default true
         */
        this.touch = true;
        /**
         * Set type of the transition.
         * @type {'slide' | 'crossfade'}
         * @default 'slide'
         */
        this.transition = 'slide';
        /**
         * Set whether the carousel should cycle continuously or have hard stops.
         * @type boolean
         * @default true
         */
        this.wrap = true;
        /**
         * Event emitted on carousel item change. [docs]
         * @type number
         */
        this.itemChange = new EventEmitter();
        this.activeItemInterval = 0;
        this.#destroyRef = inject(DestroyRef);
        this._visible = true;
        Object.assign(this, config);
    }
    get hostClasses() {
        return {
            carousel: true,
            slide: true,
            'carousel-fade': this.transition === 'crossfade'
        };
    }
    #destroyRef;
    ngOnInit() {
        this.carouselStateSubscribe();
    }
    ngOnDestroy() {
        this.resetTimer();
        this.clearListeners();
        this.swipeSubscribe(false);
    }
    ngAfterContentInit() {
        this.intersectionServiceSubscribe();
        this.carouselState.state = { activeItemIndex: this.activeIndex, animate: this.animate };
        this.setListeners();
        this.swipeSubscribe();
    }
    setListeners() {
        const config = {
            hostElement: this.hostElement,
            trigger: this.pause || [],
            callbackOff: () => {
                this.setTimer();
            },
            callbackOn: () => {
                this.resetTimer();
            }
        };
        this.listenersService.setListeners(config);
    }
    clearListeners() {
        this.listenersService.clearListeners();
    }
    set visible(value) {
        this._visible = value;
    }
    get visible() {
        return this._visible;
    }
    setTimer() {
        const interval = this.activeItemInterval || 0;
        this.resetTimer();
        if (interval > 0) {
            this.timerId = setTimeout(() => {
                const nextIndex = this.carouselState.direction(this.direction);
                this.carouselState.state = { activeItemIndex: nextIndex };
            }, interval);
        }
    }
    resetTimer() {
        clearTimeout(this.timerId);
        this.timerId = undefined;
    }
    carouselStateSubscribe() {
        this.carouselService.carouselIndex$.pipe(takeUntilDestroyed(this.#destroyRef)).subscribe((nextItem) => {
            if ('active' in nextItem) {
                this.itemChange.emit(nextItem.active);
            }
            this.activeItemInterval =
                typeof nextItem.interval === 'number' && nextItem.interval > -1 ? nextItem.interval : this.interval;
            const isLastItem = (nextItem.active === nextItem.lastItemIndex && this.direction === 'next') ||
                (nextItem.active === 0 && this.direction === 'prev');
            !this.wrap && isLastItem ? this.resetTimer() : this.setTimer();
        });
    }
    intersectionServiceSubscribe() {
        this.intersectionService.createIntersectionObserver(this.hostElement);
        this.intersectionService.intersecting$
            .pipe(filter((next) => next.hostElement === this.hostElement), finalize(() => {
            this.intersectionService.unobserve(this.hostElement);
        }), takeUntilDestroyed(this.#destroyRef))
            .subscribe((next) => {
            this.visible = next.isIntersecting;
            next.isIntersecting ? this.setTimer() : this.resetTimer();
        });
    }
    swipeSubscribe(subscribe = true) {
        if (this.touch && subscribe) {
            const carouselElement = this.hostElement.nativeElement;
            const touchStart$ = fromEvent(carouselElement, 'touchstart');
            const touchEnd$ = fromEvent(carouselElement, 'touchend');
            const touchMove$ = fromEvent(carouselElement, 'touchmove');
            this.swipeSubscription = touchStart$
                .pipe(zipWith(touchEnd$.pipe(withLatestFrom(touchMove$))), takeUntilDestroyed(this.#destroyRef))
                .subscribe(([touchstart, [touchend, touchmove]]) => {
                touchstart.stopPropagation();
                touchmove.stopPropagation();
                const distanceX = touchstart.touches[0].clientX - touchmove.touches[0].clientX;
                if (Math.abs(distanceX) > 0.3 * carouselElement.clientWidth && touchstart.timeStamp <= touchmove.timeStamp) {
                    const nextIndex = this.carouselState.direction(distanceX > 0 ? 'next' : 'prev');
                    this.carouselState.state = { activeItemIndex: nextIndex };
                }
            });
        }
        else {
            this.swipeSubscription?.unsubscribe();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.2", ngImport: i0, type: CarouselComponent, deps: [{ token: CarouselConfig }, { token: i0.ElementRef }, { token: i1.CarouselService }, { token: i2.CarouselState }, { token: i3.IntersectionService }, { token: i3.ListenersService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.2", type: CarouselComponent, isStandalone: true, selector: "c-carousel", inputs: { activeIndex: "activeIndex", animate: "animate", direction: "direction", interval: "interval", pause: "pause", touch: "touch", transition: "transition", wrap: "wrap" }, outputs: { itemChange: "itemChange" }, host: { properties: { "class": "this.hostClasses" }, classAttribute: "carousel slide" }, providers: [CarouselService, CarouselState, CarouselConfig, ListenersService], hostDirectives: [{ directive: i4.ThemeDirective, inputs: ["dark", "dark"] }], ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.2", ngImport: i0, type: CarouselComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-carousel', template: '<ng-content />', providers: [CarouselService, CarouselState, CarouselConfig, ListenersService], standalone: true, hostDirectives: [{ directive: ThemeDirective, inputs: ['dark'] }], host: { class: 'carousel slide' }, styles: [":host{display:block}\n"] }]
        }], ctorParameters: () => [{ type: i5.CarouselConfig, decorators: [{
                    type: Inject,
                    args: [CarouselConfig]
                }] }, { type: i0.ElementRef }, { type: i1.CarouselService }, { type: i2.CarouselState }, { type: i3.IntersectionService }, { type: i3.ListenersService }], propDecorators: { activeIndex: [{
                type: Input
            }], animate: [{
                type: Input
            }], direction: [{
                type: Input
            }], interval: [{
                type: Input
            }], pause: [{
                type: Input
            }], touch: [{
                type: Input
            }], transition: [{
                type: Input
            }], wrap: [{
                type: Input
            }], itemChange: [{
                type: Output
            }], hostClasses: [{
                type: HostBinding,
                args: ['class']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2Fyb3VzZWwuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvY29yZXVpLWFuZ3VsYXIvc3JjL2xpYi9jYXJvdXNlbC9jYXJvdXNlbC9jYXJvdXNlbC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUVMLFNBQVMsRUFDVCxVQUFVLEVBRVYsWUFBWSxFQUNaLFdBQVcsRUFDWCxNQUFNLEVBQ04sTUFBTSxFQUNOLEtBQUssRUFHTCxNQUFNLEVBQ1AsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDaEUsT0FBTyxFQUFFLFNBQVMsRUFBZ0IsTUFBTSxNQUFNLENBQUM7QUFDL0MsT0FBTyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsY0FBYyxFQUFFLE9BQU8sRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTNFLE9BQU8sRUFBeUMsZ0JBQWdCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUd6RixPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFDOUQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ2xELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN0RCxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sb0JBQW9CLENBQUM7Ozs7Ozs7QUFXcEQsTUFBTSxPQUFPLGlCQUFpQjtJQUM1QixZQUNrQyxNQUFzQixFQUM5QyxXQUF1QixFQUN2QixlQUFnQyxFQUNoQyxhQUE0QixFQUM1QixtQkFBd0MsRUFDeEMsZ0JBQWtDO1FBTFYsV0FBTSxHQUFOLE1BQU0sQ0FBZ0I7UUFDOUMsZ0JBQVcsR0FBWCxXQUFXLENBQVk7UUFDdkIsb0JBQWUsR0FBZixlQUFlLENBQWlCO1FBQ2hDLGtCQUFhLEdBQWIsYUFBYSxDQUFlO1FBQzVCLHdC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QUFjO2tHQUZiLGlCQUFpQiwyV0FMakIsQ0FBQyxlQUFlLEVBQUUsYUFBYSxFQUFFLGNBQWMsRUFBRSxnQkFBZ0IsQ0FBQyx3R0FGbkUsZ0JBQWdCOzsyRkFPZixpQkFBaUI7a0JBVDdCLFNBQVM7K0JBQ0UsWUFBWSxZQUNaLGdCQUFnQixhQUVmLENBQUMsZUFBZSxFQUFFLGFBQWEsRUFBRSxjQUFjLEVBQUUsZ0JBQWdCLENBQUMsY0FDakUsSUFBSSxrQkFDQSxDQUFDLEVBQUUsU0FBUyxFQUFFLGNBQWMsRUFBRSxNQUFNLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFFBQzNELEVBQUUsS0FBSyxFQUFFLGdCQUFnQixFQUFFOzswQkFJOUIsTUFBTTsyQkFBQyxjQUFjOzZMQWNmLFdBQVc7c0JBQW5CLEtBQUs7Z0JBS0csT0FBTztzQkFBZixLQUFLO2dCQUtHLFNBQVM7c0JBQWpCLEtBQUs7Z0JBTUcsUUFBUTtzQkFBaEIsS0FBSztnQkFLRyxLQUFLO3NCQUFiLEtBQUs7Z0JBTUcsS0FBSztzQkFBYixLQUFLO2dCQU1HLFVBQVU7c0JBQWxCLEtBQUs7Z0JBTUcsSUFBSTtzQkFBWixLQUFLO2dCQUtJLFVBQVU7c0JBQW5CLE1BQU07Z0JBR0gsV0FBVztzQkFEZCxXQUFXO3VCQUFDLE9BQU8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBDb21wb25lbnQsXG4gIERlc3Ryb3lSZWYsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSG9zdEJpbmRpbmcsXG4gIGluamVjdCxcbiAgSW5qZWN0LFxuICBJbnB1dCxcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIE91dHB1dFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHRha2VVbnRpbERlc3Ryb3llZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUvcnhqcy1pbnRlcm9wJztcbmltcG9ydCB7IGZyb21FdmVudCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIGZpbmFsaXplLCB3aXRoTGF0ZXN0RnJvbSwgemlwV2l0aCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgSUxpc3RlbmVyc0NvbmZpZywgSW50ZXJzZWN0aW9uU2VydmljZSwgTGlzdGVuZXJzU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzJztcblxuaW1wb3J0IHsgVHJpZ2dlcnMgfSBmcm9tICcuLi8uLi9jb3JldWkudHlwZXMnO1xuaW1wb3J0IHsgVGhlbWVEaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9zaGFyZWQvdGhlbWUuZGlyZWN0aXZlJztcbmltcG9ydCB7IENhcm91c2VsU3RhdGUgfSBmcm9tICcuLi9jYXJvdXNlbC1zdGF0ZSc7XG5pbXBvcnQgeyBDYXJvdXNlbFNlcnZpY2UgfSBmcm9tICcuLi9jYXJvdXNlbC5zZXJ2aWNlJztcbmltcG9ydCB7IENhcm91c2VsQ29uZmlnIH0gZnJvbSAnLi4vY2Fyb3VzZWwuY29uZmlnJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYy1jYXJvdXNlbCcsXG4gIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQgLz4nLFxuICBzdHlsZVVybHM6IFsnLi9jYXJvdXNlbC5jb21wb25lbnQuc2NzcyddLFxuICBwcm92aWRlcnM6IFtDYXJvdXNlbFNlcnZpY2UsIENhcm91c2VsU3RhdGUsIENhcm91c2VsQ29uZmlnLCBMaXN0ZW5lcnNTZXJ2aWNlXSxcbiAgc3RhbmRhbG9uZTogdHJ1ZSxcbiAgaG9zdERpcmVjdGl2ZXM6IFt7IGRpcmVjdGl2ZTogVGhlbWVEaXJlY3RpdmUsIGlucHV0czogWydkYXJrJ10gfV0sXG4gIGhvc3Q6IHsgY2xhc3M6ICdjYXJvdXNlbCBzbGlkZScgfVxufSlcbmV4cG9ydCBjbGFzcyBDYXJvdXNlbENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95LCBBZnRlckNvbnRlbnRJbml0IHtcbiAgY29uc3RydWN0b3IoXG4gICAgQEluamVjdChDYXJvdXNlbENvbmZpZykgcHJpdmF0ZSBjb25maWc6IENhcm91c2VsQ29uZmlnLFxuICAgIHByaXZhdGUgaG9zdEVsZW1lbnQ6IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSBjYXJvdXNlbFNlcnZpY2U6IENhcm91c2VsU2VydmljZSxcbiAgICBwcml2YXRlIGNhcm91c2VsU3RhdGU6IENhcm91c2VsU3RhdGUsXG4gICAgcHJpdmF0ZSBpbnRlcnNlY3Rpb25TZXJ2aWNlOiBJbnRlcnNlY3Rpb25TZXJ2aWNlLFxuICAgIHByaXZhdGUgbGlzdGVuZXJzU2VydmljZTogTGlzdGVuZXJzU2VydmljZVxuICApIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNvbmZpZyk7XG4gIH1cblxuICAvKipcbiAgICogSW5kZXggb2YgdGhlIGFjdGl2ZSBpdGVtLlxuICAgKiBAdHlwZSBudW1iZXJcbiAgICovXG4gIEBJbnB1dCgpIGFjdGl2ZUluZGV4OiBudW1iZXIgPSAwO1xuICAvKipcbiAgICogQ2Fyb3VzZWwgYXV0b21hdGljYWxseSBzdGFydHMgY3ljbGUgaXRlbXMuXG4gICAqIEB0eXBlIGJvb2xlYW5cbiAgICovXG4gIEBJbnB1dCgpIGFuaW1hdGU6IGJvb2xlYW4gPSB0cnVlO1xuICAvKipcbiAgICogQ2Fyb3VzZWwgZGlyZWN0aW9uLiBbZG9jc11cbiAgICogQHR5cGUgeyduZXh0JyB8ICdwcmV2J31cbiAgICovXG4gIEBJbnB1dCgpIGRpcmVjdGlvbjogJ25leHQnIHwgJ3ByZXYnID0gJ25leHQnO1xuICAvKipcbiAgICogVGhlIGFtb3VudCBvZiB0aW1lIHRvIGRlbGF5IGJldHdlZW4gYXV0b21hdGljYWxseSBjeWNsaW5nIGFuIGl0ZW0uIElmIGZhbHNlLCBjYXJvdXNlbCB3aWxsIG5vdCBhdXRvbWF0aWNhbGx5IGN5Y2xlLlxuICAgKiBAdHlwZSBudW1iZXJcbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgQElucHV0KCkgaW50ZXJ2YWw6IG51bWJlciA9IDA7XG4gIC8qKlxuICAgKiBTZXRzIHdoaWNoIGV2ZW50IGhhbmRsZXJzIHlvdeKAmWQgbGlrZSBwcm92aWRlZCB0byB5b3VyIHBhdXNlIHByb3AuIFlvdSBjYW4gc3BlY2lmeSBvbmUgdHJpZ2dlciBvciBhbiBhcnJheSBvZiB0aGVtLlxuICAgKiBAdHlwZSB7J2hvdmVyJyB8ICdmb2N1cycgfCAnY2xpY2snfVxuICAgKi9cbiAgQElucHV0KCkgcGF1c2U6IFRyaWdnZXJzIHwgVHJpZ2dlcnNbXSB8IGZhbHNlID0gJ2hvdmVyJztcbiAgLyoqXG4gICAqIFN1cHBvcnQgbGVmdC9yaWdodCBzd2lwZSBpbnRlcmFjdGlvbnMgb24gdG91Y2hzY3JlZW4gZGV2aWNlcy5cbiAgICogQHR5cGUgYm9vbGVhblxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBASW5wdXQoKSB0b3VjaDogYm9vbGVhbiA9IHRydWU7XG4gIC8qKlxuICAgKiBTZXQgdHlwZSBvZiB0aGUgdHJhbnNpdGlvbi5cbiAgICogQHR5cGUgeydzbGlkZScgfCAnY3Jvc3NmYWRlJ31cbiAgICogQGRlZmF1bHQgJ3NsaWRlJ1xuICAgKi9cbiAgQElucHV0KCkgdHJhbnNpdGlvbjogJ3NsaWRlJyB8ICdjcm9zc2ZhZGUnID0gJ3NsaWRlJztcbiAgLyoqXG4gICAqIFNldCB3aGV0aGVyIHRoZSBjYXJvdXNlbCBzaG91bGQgY3ljbGUgY29udGludW91c2x5IG9yIGhhdmUgaGFyZCBzdG9wcy5cbiAgICogQHR5cGUgYm9vbGVhblxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBASW5wdXQoKSB3cmFwOiBib29sZWFuID0gdHJ1ZTtcbiAgLyoqXG4gICAqIEV2ZW50IGVtaXR0ZWQgb24gY2Fyb3VzZWwgaXRlbSBjaGFuZ2UuIFtkb2NzXVxuICAgKiBAdHlwZSBudW1iZXJcbiAgICovXG4gIEBPdXRwdXQoKSBpdGVtQ2hhbmdlOiBFdmVudEVtaXR0ZXI8bnVtYmVyPiA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG4gIEBIb3N0QmluZGluZygnY2xhc3MnKVxuICBnZXQgaG9zdENsYXNzZXMoKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgY2Fyb3VzZWw6IHRydWUsXG4gICAgICBzbGlkZTogdHJ1ZSxcbiAgICAgICdjYXJvdXNlbC1mYWRlJzogdGhpcy50cmFuc2l0aW9uID09PSAnY3Jvc3NmYWRlJ1xuICAgIH07XG4gIH1cblxuICBwcml2YXRlIHRpbWVySWQ6IFJldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+IHwgdW5kZWZpbmVkO1xuICBwcml2YXRlIGFjdGl2ZUl0ZW1JbnRlcnZhbCA9IDA7XG4gIHByaXZhdGUgc3dpcGVTdWJzY3JpcHRpb24/OiBTdWJzY3JpcHRpb247XG4gIHJlYWRvbmx5ICNkZXN0cm95UmVmID0gaW5qZWN0KERlc3Ryb3lSZWYpO1xuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIHRoaXMuY2Fyb3VzZWxTdGF0ZVN1YnNjcmliZSgpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5yZXNldFRpbWVyKCk7XG4gICAgdGhpcy5jbGVhckxpc3RlbmVycygpO1xuICAgIHRoaXMuc3dpcGVTdWJzY3JpYmUoZmFsc2UpO1xuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xuICAgIHRoaXMuaW50ZXJzZWN0aW9uU2VydmljZVN1YnNjcmliZSgpO1xuICAgIHRoaXMuY2Fyb3VzZWxTdGF0ZS5zdGF0ZSA9IHsgYWN0aXZlSXRlbUluZGV4OiB0aGlzLmFjdGl2ZUluZGV4LCBhbmltYXRlOiB0aGlzLmFuaW1hdGUgfTtcbiAgICB0aGlzLnNldExpc3RlbmVycygpO1xuICAgIHRoaXMuc3dpcGVTdWJzY3JpYmUoKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0TGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIGNvbnN0IGNvbmZpZzogSUxpc3RlbmVyc0NvbmZpZyA9IHtcbiAgICAgIGhvc3RFbGVtZW50OiB0aGlzLmhvc3RFbGVtZW50LFxuICAgICAgdHJpZ2dlcjogdGhpcy5wYXVzZSB8fCBbXSxcbiAgICAgIGNhbGxiYWNrT2ZmOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0VGltZXIoKTtcbiAgICAgIH0sXG4gICAgICBjYWxsYmFja09uOiAoKSA9PiB7XG4gICAgICAgIHRoaXMucmVzZXRUaW1lcigpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5saXN0ZW5lcnNTZXJ2aWNlLnNldExpc3RlbmVycyhjb25maWcpO1xuICB9XG5cbiAgcHJpdmF0ZSBjbGVhckxpc3RlbmVycygpOiB2b2lkIHtcbiAgICB0aGlzLmxpc3RlbmVyc1NlcnZpY2UuY2xlYXJMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIHNldCB2aXNpYmxlKHZhbHVlKSB7XG4gICAgdGhpcy5fdmlzaWJsZSA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gIH1cblxuICBwcml2YXRlIF92aXNpYmxlOiBib29sZWFuID0gdHJ1ZTtcblxuICBzZXRUaW1lcigpOiB2b2lkIHtcbiAgICBjb25zdCBpbnRlcnZhbCA9IHRoaXMuYWN0aXZlSXRlbUludGVydmFsIHx8IDA7XG4gICAgdGhpcy5yZXNldFRpbWVyKCk7XG4gICAgaWYgKGludGVydmFsID4gMCkge1xuICAgICAgdGhpcy50aW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5leHRJbmRleCA9IHRoaXMuY2Fyb3VzZWxTdGF0ZS5kaXJlY3Rpb24odGhpcy5kaXJlY3Rpb24pO1xuICAgICAgICB0aGlzLmNhcm91c2VsU3RhdGUuc3RhdGUgPSB7IGFjdGl2ZUl0ZW1JbmRleDogbmV4dEluZGV4IH07XG4gICAgICB9LCBpbnRlcnZhbCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRUaW1lcigpOiB2b2lkIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcklkKTtcbiAgICB0aGlzLnRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBwcml2YXRlIGNhcm91c2VsU3RhdGVTdWJzY3JpYmUoKTogdm9pZCB7XG4gICAgdGhpcy5jYXJvdXNlbFNlcnZpY2UuY2Fyb3VzZWxJbmRleCQucGlwZSh0YWtlVW50aWxEZXN0cm95ZWQodGhpcy4jZGVzdHJveVJlZikpLnN1YnNjcmliZSgobmV4dEl0ZW0pID0+IHtcbiAgICAgIGlmICgnYWN0aXZlJyBpbiBuZXh0SXRlbSkge1xuICAgICAgICB0aGlzLml0ZW1DaGFuZ2UuZW1pdChuZXh0SXRlbS5hY3RpdmUpO1xuICAgICAgfVxuICAgICAgdGhpcy5hY3RpdmVJdGVtSW50ZXJ2YWwgPVxuICAgICAgICB0eXBlb2YgbmV4dEl0ZW0uaW50ZXJ2YWwgPT09ICdudW1iZXInICYmIG5leHRJdGVtLmludGVydmFsID4gLTEgPyBuZXh0SXRlbS5pbnRlcnZhbCA6IHRoaXMuaW50ZXJ2YWw7XG4gICAgICBjb25zdCBpc0xhc3RJdGVtID1cbiAgICAgICAgKG5leHRJdGVtLmFjdGl2ZSA9PT0gbmV4dEl0ZW0ubGFzdEl0ZW1JbmRleCAmJiB0aGlzLmRpcmVjdGlvbiA9PT0gJ25leHQnKSB8fFxuICAgICAgICAobmV4dEl0ZW0uYWN0aXZlID09PSAwICYmIHRoaXMuZGlyZWN0aW9uID09PSAncHJldicpO1xuICAgICAgIXRoaXMud3JhcCAmJiBpc0xhc3RJdGVtID8gdGhpcy5yZXNldFRpbWVyKCkgOiB0aGlzLnNldFRpbWVyKCk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGludGVyc2VjdGlvblNlcnZpY2VTdWJzY3JpYmUoKTogdm9pZCB7XG4gICAgdGhpcy5pbnRlcnNlY3Rpb25TZXJ2aWNlLmNyZWF0ZUludGVyc2VjdGlvbk9ic2VydmVyKHRoaXMuaG9zdEVsZW1lbnQpO1xuICAgIHRoaXMuaW50ZXJzZWN0aW9uU2VydmljZS5pbnRlcnNlY3RpbmckXG4gICAgICAucGlwZShcbiAgICAgICAgZmlsdGVyKChuZXh0KSA9PiBuZXh0Lmhvc3RFbGVtZW50ID09PSB0aGlzLmhvc3RFbGVtZW50KSxcbiAgICAgICAgZmluYWxpemUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uU2VydmljZS51bm9ic2VydmUodGhpcy5ob3N0RWxlbWVudCk7XG4gICAgICAgIH0pLFxuICAgICAgICB0YWtlVW50aWxEZXN0cm95ZWQodGhpcy4jZGVzdHJveVJlZilcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoKG5leHQpID0+IHtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gbmV4dC5pc0ludGVyc2VjdGluZztcbiAgICAgICAgbmV4dC5pc0ludGVyc2VjdGluZyA/IHRoaXMuc2V0VGltZXIoKSA6IHRoaXMucmVzZXRUaW1lcigpO1xuICAgICAgfSk7XG4gIH1cblxuICBwcml2YXRlIHN3aXBlU3Vic2NyaWJlKHN1YnNjcmliZTogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcbiAgICBpZiAodGhpcy50b3VjaCAmJiBzdWJzY3JpYmUpIHtcbiAgICAgIGNvbnN0IGNhcm91c2VsRWxlbWVudCA9IHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgIGNvbnN0IHRvdWNoU3RhcnQkID0gZnJvbUV2ZW50PFRvdWNoRXZlbnQ+KGNhcm91c2VsRWxlbWVudCwgJ3RvdWNoc3RhcnQnKTtcbiAgICAgIGNvbnN0IHRvdWNoRW5kJCA9IGZyb21FdmVudDxUb3VjaEV2ZW50PihjYXJvdXNlbEVsZW1lbnQsICd0b3VjaGVuZCcpO1xuICAgICAgY29uc3QgdG91Y2hNb3ZlJCA9IGZyb21FdmVudDxUb3VjaEV2ZW50PihjYXJvdXNlbEVsZW1lbnQsICd0b3VjaG1vdmUnKTtcbiAgICAgIHRoaXMuc3dpcGVTdWJzY3JpcHRpb24gPSB0b3VjaFN0YXJ0JFxuICAgICAgICAucGlwZSh6aXBXaXRoKHRvdWNoRW5kJC5waXBlKHdpdGhMYXRlc3RGcm9tKHRvdWNoTW92ZSQpKSksIHRha2VVbnRpbERlc3Ryb3llZCh0aGlzLiNkZXN0cm95UmVmKSlcbiAgICAgICAgLnN1YnNjcmliZSgoW3RvdWNoc3RhcnQsIFt0b3VjaGVuZCwgdG91Y2htb3ZlXV0pID0+IHtcbiAgICAgICAgICB0b3VjaHN0YXJ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIHRvdWNobW92ZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBjb25zdCBkaXN0YW5jZVggPSB0b3VjaHN0YXJ0LnRvdWNoZXNbMF0uY2xpZW50WCAtIHRvdWNobW92ZS50b3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICAgICAgaWYgKE1hdGguYWJzKGRpc3RhbmNlWCkgPiAwLjMgKiBjYXJvdXNlbEVsZW1lbnQuY2xpZW50V2lkdGggJiYgdG91Y2hzdGFydC50aW1lU3RhbXAgPD0gdG91Y2htb3ZlLnRpbWVTdGFtcCkge1xuICAgICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gdGhpcy5jYXJvdXNlbFN0YXRlLmRpcmVjdGlvbihkaXN0YW5jZVggPiAwID8gJ25leHQnIDogJ3ByZXYnKTtcbiAgICAgICAgICAgIHRoaXMuY2Fyb3VzZWxTdGF0ZS5zdGF0ZSA9IHsgYWN0aXZlSXRlbUluZGV4OiBuZXh0SW5kZXggfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN3aXBlU3Vic2NyaXB0aW9uPy51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxufVxuIl19