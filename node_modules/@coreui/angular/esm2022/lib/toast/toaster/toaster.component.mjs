import { Component, ContentChildren, DestroyRef, HostBinding, inject, Input, ViewChild, ViewContainerRef } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { ToasterHostDirective } from './toaster-host.directive';
import { ToastComponent } from '../toast/toast.component';
import * as i0 from "@angular/core";
import * as i1 from "./toaster.service";
export var ToasterPlacement;
(function (ToasterPlacement) {
    ToasterPlacement["Static"] = "static";
    ToasterPlacement["TopStart"] = "top-start";
    ToasterPlacement["TopCenter"] = "top-center";
    ToasterPlacement["TopEnd"] = "top-end";
    ToasterPlacement["MiddleStart"] = "middle-start";
    ToasterPlacement["MiddleCenter"] = "middle-center";
    ToasterPlacement["MiddleEnd"] = "middle-end";
    ToasterPlacement["BottomStart"] = "bottom-start";
    ToasterPlacement["BottomCenter"] = "bottom-center";
    ToasterPlacement["BottomEnd"] = "bottom-end";
})(ToasterPlacement || (ToasterPlacement = {}));
export class ToasterComponent {
    #destroyRef;
    constructor(hostElement, renderer, toasterService) {
        this.hostElement = hostElement;
        this.renderer = renderer;
        this.toasterService = toasterService;
        this.#destroyRef = inject(DestroyRef);
        this.placements = Object.values(ToasterPlacement);
        this.toastsDynamic = [];
        /**
         * Toaster placement
         * @type TToasterPlacement
         */
        this.placement = ToasterPlacement.TopEnd;
        /**
         * Toaster position
         * @type (string | 'absolute' | 'fixed' | 'static')
         */
        this.position = 'absolute';
    }
    get hostClasses() {
        return {
            toaster: true,
            'toast-container': true,
            [`position-${this.position}`]: !!this.position,
            'top-0': this.placement.includes('top'),
            'top-50': this.placement.includes('middle'),
            'bottom-0': this.placement.includes('bottom'),
            'start-0': this.placement.includes('start'),
            'start-50': this.placement.includes('center'),
            'end-0': this.placement.includes('end'),
            'translate-middle-x': this.placement.includes('center') && !this.placement.includes('middle'),
            'translate-middle-y': this.placement.includes('middle') && !this.placement.includes('center'),
            'translate-middle': this.placement.includes('middle') && this.placement.includes('center')
        };
    }
    ngOnInit() {
        this.stateToasterSubscribe();
    }
    ngAfterContentChecked() {
        this.toasts = this.contentToasts;
    }
    addToast(toast, props, options) {
        const componentRef = this.toasterHost.viewContainerRef.createComponent(toast, options);
        this.toastsDynamic.push(componentRef);
        const index = this.toastsDynamic.indexOf(componentRef);
        for (const [key, value] of Object.entries(props)) {
            componentRef.instance[key] = value;
        }
        componentRef.instance['placement'] = this.placement;
        componentRef.instance['dynamic'] = true;
        componentRef.instance['index'] = index;
        componentRef.instance['visible'] = true;
        componentRef.instance['visibleChange'].emit(true);
        componentRef.changeDetectorRef?.detectChanges();
        return componentRef;
    }
    removeToast(state) {
        this.toastsDynamic?.forEach((item) => {
            if (state.toast?.dynamic && item.instance === state.toast) {
                item.instance.visible = false;
                item.instance['visibleChange'].emit(false);
                item.destroy();
            }
        });
        this.toasts?.forEach((item) => {
            if (state.toast && item.element.nativeElement === state.toast.hostElement.nativeElement) {
                if (!state.toast.dynamic) {
                    state.toast.visible = false;
                }
            }
        });
    }
    stateToasterSubscribe() {
        this.toasterService.toasterState$.pipe(takeUntilDestroyed(this.#destroyRef)).subscribe((state) => {
            if (state.show === false) {
                this.removeToast(state);
            }
            if (state.show === true && state.toast?.dynamic === undefined) {
                /* empty */
            }
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.2", ngImport: i0, type: ToasterComponent, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i1.ToasterService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.2", type: ToasterComponent, isStandalone: true, selector: "c-toaster", inputs: { placement: "placement", position: "position" }, host: { properties: { "class": "this.hostClasses" }, classAttribute: "toaster toast-container" }, queries: [{ propertyName: "contentToasts", predicate: ToastComponent, read: ViewContainerRef }], viewQueries: [{ propertyName: "toasterHost", first: true, predicate: ToasterHostDirective, descendants: true, static: true }], exportAs: ["cToaster"], ngImport: i0, template: "<ng-template cToasterHost />\n<ng-content cToasterHost />\n", dependencies: [{ kind: "directive", type: ToasterHostDirective, selector: "[cToasterHost]", exportAs: ["cToasterHost"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.2", ngImport: i0, type: ToasterComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-toaster', exportAs: 'cToaster', standalone: true, imports: [ToasterHostDirective], host: { class: 'toaster toast-container' }, template: "<ng-template cToasterHost />\n<ng-content cToasterHost />\n" }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i1.ToasterService }], propDecorators: { placement: [{
                type: Input
            }], position: [{
                type: Input
            }], toasterHost: [{
                type: ViewChild,
                args: [ToasterHostDirective, { static: true }]
            }], contentToasts: [{
                type: ContentChildren,
                args: [ToastComponent, { read: ViewContainerRef }]
            }], hostClasses: [{
                type: HostBinding,
                args: ['class']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9hc3Rlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9jb3JldWktYW5ndWxhci9zcmMvbGliL3RvYXN0L3RvYXN0ZXIvdG9hc3Rlci5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9jb3JldWktYW5ndWxhci9zcmMvbGliL3RvYXN0L3RvYXN0ZXIvdG9hc3Rlci5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBRUwsU0FBUyxFQUVULGVBQWUsRUFDZixVQUFVLEVBRVYsV0FBVyxFQUNYLE1BQU0sRUFFTixLQUFLLEVBS0wsU0FBUyxFQUNULGdCQUFnQixFQUNqQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUdoRSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUNoRSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sMEJBQTBCLENBQUM7OztBQUUxRCxNQUFNLENBQU4sSUFBWSxnQkFXWDtBQVhELFdBQVksZ0JBQWdCO0lBQzFCLHFDQUFpQixDQUFBO0lBQ2pCLDBDQUFzQixDQUFBO0lBQ3RCLDRDQUF3QixDQUFBO0lBQ3hCLHNDQUFrQixDQUFBO0lBQ2xCLGdEQUE0QixDQUFBO0lBQzVCLGtEQUE4QixDQUFBO0lBQzlCLDRDQUF3QixDQUFBO0lBQ3hCLGdEQUE0QixDQUFBO0lBQzVCLGtEQUE4QixDQUFBO0lBQzlCLDRDQUF3QixDQUFBO0FBQzFCLENBQUMsRUFYVyxnQkFBZ0IsS0FBaEIsZ0JBQWdCLFFBVzNCO0FBdUJELE1BQU0sT0FBTyxnQkFBZ0I7SUFDbEIsV0FBVyxDQUFzQjtJQUUxQyxZQUNVLFdBQXVCLEVBQ3ZCLFFBQW1CLEVBQ25CLGNBQThCO1FBRjlCLGdCQUFXLEdBQVgsV0FBVyxDQUFZO1FBQ3ZCLGFB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LENBQUMsU0FBUyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUU7WUFDL0YsSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLEtBQUssRUFBRSxDQUFDO2dCQUN6QixJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzFCLENBQUM7WUFDRCxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssSUFBSSxJQUFJLEtBQUssQ0FBQyxLQUFLLEVBQUUsT0FBTyxLQUFLLFNBQVMsRUFBRSxDQUFDO2dCQUM5RCxXQUFXO1lBQ2IsQ0FBQztRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQzs4R0ExR1UsZ0JBQWdCO2tHQUFoQixnQkFBZ0IsK1BBMEJWLGNBQWMsUUFBVSxnQkFBZ0IsMEVBRDlDLG9CQUFvQixzRkNuRmpDLDZEQUVBLDRDRHFEWSxvQkFBb0I7OzJGQUduQixnQkFBZ0I7a0JBUjVCLFNBQVM7K0JBQ0UsV0FBVyxZQUVYLFVBQVUsY0FDUixJQUFJLFdBQ1AsQ0FBQyxvQkFBb0IsQ0FBQyxRQUN6QixFQUFFLEtBQUssRUFBRSx5QkFBeUIsRUFBRTtvSUFtQmpDLFNBQVM7c0JBQWpCLEtBQUs7Z0JBTUcsUUFBUTtzQkFBaEIsS0FBSztnQkFFNkMsV0FBVztzQkFBN0QsU0FBUzt1QkFBQyxvQkFBb0IsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7Z0JBQ1ksYUFBYTtzQkFBekUsZUFBZTt1QkFBQyxjQUFjLEVBQUUsRUFBRSxJQUFJLEVBQUUsZ0JBQWdCLEVBQUU7Z0JBR3ZELFdBQVc7c0JBRGQsV0FBVzt1QkFBQyxPQUFPIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50Q2hlY2tlZCxcbiAgQ29tcG9uZW50LFxuICBDb21wb25lbnRSZWYsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRGVzdHJveVJlZixcbiAgRWxlbWVudFJlZixcbiAgSG9zdEJpbmRpbmcsXG4gIGluamVjdCxcbiAgSW5qZWN0b3IsXG4gIElucHV0LFxuICBOZ01vZHVsZVJlZixcbiAgT25Jbml0LFxuICBRdWVyeUxpc3QsXG4gIFJlbmRlcmVyMixcbiAgVmlld0NoaWxkLFxuICBWaWV3Q29udGFpbmVyUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgdGFrZVVudGlsRGVzdHJveWVkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZS9yeGpzLWludGVyb3AnO1xuXG5pbXBvcnQgeyBJVG9hc3RlckFjdGlvbiwgVG9hc3RlclNlcnZpY2UgfSBmcm9tICcuL3RvYXN0ZXIuc2VydmljZSc7XG5pbXBvcnQgeyBUb2FzdGVySG9zdERpcmVjdGl2ZSB9IGZyb20gJy4vdG9hc3Rlci1ob3N0LmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBUb2FzdENvbXBvbmVudCB9IGZyb20gJy4uL3RvYXN0L3RvYXN0LmNvbXBvbmVudCc7XG5cbmV4cG9ydCBlbnVtIFRvYXN0ZXJQbGFjZW1lbnQge1xuICBTdGF0aWMgPSAnc3RhdGljJyxcbiAgVG9wU3RhcnQgPSAndG9wLXN0YXJ0JyxcbiAgVG9wQ2VudGVyID0gJ3RvcC1jZW50ZXInLFxuICBUb3BFbmQgPSAndG9wLWVuZCcsXG4gIE1pZGRsZVN0YXJ0ID0gJ21pZGRsZS1zdGFydCcsXG4gIE1pZGRsZUNlbnRlciA9ICdtaWRkbGUtY2VudGVyJyxcbiAgTWlkZGxlRW5kID0gJ21pZGRsZS1lbmQnLFxuICBCb3R0b21TdGFydCA9ICdib3R0b20tc3RhcnQnLFxuICBCb3R0b21DZW50ZXIgPSAnYm90dG9tLWNlbnRlcicsXG4gIEJvdHRvbUVuZCA9ICdib3R0b20tZW5kJ1xufVxuXG5leHBvcnQgdHlwZSBUVG9hc3RlclBsYWNlbWVudCA9XG4gIHwgVG9hc3RlclBsYWNlbWVudC5TdGF0aWNcbiAgfCBUb2FzdGVyUGxhY2VtZW50LlRvcFN0YXJ0XG4gIHwgVG9hc3RlclBsYWNlbWVudC5Ub3BDZW50ZXJcbiAgfCBUb2FzdGVyUGxhY2VtZW50LlRvcEVuZFxuICB8IFRvYXN0ZXJQbGFjZW1lbnQuTWlkZGxlU3RhcnRcbiAgfCBUb2FzdGVyUGxhY2VtZW50Lk1pZGRsZUNlbnRlclxuICB8IFRvYXN0ZXJQbGFjZW1lbnQuTWlkZGxlRW5kXG4gIHwgVG9hc3RlclBsYWNlbWVudC5Cb3R0b21TdGFydFxuICB8IFRvYXN0ZXJQbGFjZW1lbnQuQm90dG9tQ2VudGVyXG4gIHwgVG9hc3RlclBsYWNlbWVudC5Cb3R0b21FbmRcbiAgfCBzdHJpbmc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2MtdG9hc3RlcicsXG4gIHRlbXBsYXRlVXJsOiAnLi90b2FzdGVyLmNvbXBvbmVudC5odG1sJyxcbiAgZXhwb3J0QXM6ICdjVG9hc3RlcicsXG4gIHN0YW5kYWxvbmU6IHRydWUsXG4gIGltcG9ydHM6IFtUb2FzdGVySG9zdERpcmVjdGl2ZV0sXG4gIGhvc3Q6IHsgY2xhc3M6ICd0b2FzdGVyIHRvYXN0LWNvbnRhaW5lcicgfVxufSlcbmV4cG9ydCBjbGFzcyBUb2FzdGVyQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBBZnRlckNvbnRlbnRDaGVja2VkIHtcbiAgcmVhZG9ubHkgI2Rlc3Ryb3lSZWYgPSBpbmplY3QoRGVzdHJveVJlZik7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBob3N0RWxlbWVudDogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSB0b2FzdGVyU2VydmljZTogVG9hc3RlclNlcnZpY2VcbiAgKSB7fVxuXG4gIHBsYWNlbWVudHMgPSBPYmplY3QudmFsdWVzKFRvYXN0ZXJQbGFjZW1lbnQpO1xuICB0b2FzdHMhOiBRdWVyeUxpc3Q8Vmlld0NvbnRhaW5lclJlZj47XG4gIHRvYXN0c0R5bmFtaWM6IGFueVtdID0gW107XG5cbiAgLyoqXG4gICAqIFRvYXN0ZXIgcGxhY2VtZW50XG4gICAqIEB0eXBlIFRUb2FzdGVyUGxhY2VtZW50XG4gICAqL1xuICBASW5wdXQoKSBwbGFjZW1lbnQ6IFRUb2FzdGVyUGxhY2VtZW50ID0gVG9hc3RlclBsYWNlbWVudC5Ub3BFbmQ7XG5cbiAgLyoqXG4gICAqIFRvYXN0ZXIgcG9zaXRpb25cbiAgICogQHR5cGUgKHN0cmluZyB8ICdhYnNvbHV0ZScgfCAnZml4ZWQnIHwgJ3N0YXRpYycpXG4gICAqL1xuICBASW5wdXQoKSBwb3NpdGlvbjogc3RyaW5nIHwgJ2Fic29sdXRlJyB8ICdmaXhlZCcgfCAnc3RhdGljJyA9ICdhYnNvbHV0ZSc7XG5cbiAgQFZpZXdDaGlsZChUb2FzdGVySG9zdERpcmVjdGl2ZSwgeyBzdGF0aWM6IHRydWUgfSkgdG9hc3Rlckhvc3QhOiBUb2FzdGVySG9zdERpcmVjdGl2ZTtcbiAgQENvbnRlbnRDaGlsZHJlbihUb2FzdENvbXBvbmVudCwgeyByZWFkOiBWaWV3Q29udGFpbmVyUmVmIH0pIGNvbnRlbnRUb2FzdHMhOiBRdWVyeUxpc3Q8Vmlld0NvbnRhaW5lclJlZj47XG5cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcycpXG4gIGdldCBob3N0Q2xhc3NlcygpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICB0b2FzdGVyOiB0cnVlLFxuICAgICAgJ3RvYXN0LWNvbnRhaW5lcic6IHRydWUsXG4gICAgICBbYHBvc2l0aW9uLSR7dGhpcy5wb3NpdGlvbn1gXTogISF0aGlzLnBvc2l0aW9uLFxuICAgICAgJ3RvcC0wJzogdGhpcy5wbGFjZW1lbnQuaW5jbHVkZXMoJ3RvcCcpLFxuICAgICAgJ3RvcC01MCc6IHRoaXMucGxhY2VtZW50LmluY2x1ZGVzKCdtaWRkbGUnKSxcbiAgICAgICdib3R0b20tMCc6IHRoaXMucGxhY2VtZW50LmluY2x1ZGVzKCdib3R0b20nKSxcbiAgICAgICdzdGFydC0wJzogdGhpcy5wbGFjZW1lbnQuaW5jbHVkZXMoJ3N0YXJ0JyksXG4gICAgICAnc3RhcnQtNTAnOiB0aGlzLnBsYWNlbWVudC5pbmNsdWRlcygnY2VudGVyJyksXG4gICAgICAnZW5kLTAnOiB0aGlzLnBsYWNlbWVudC5pbmNsdWRlcygnZW5kJyksXG4gICAgICAndHJhbnNsYXRlLW1pZGRsZS14JzogdGhpcy5wbGFjZW1lbnQuaW5jbHVkZXMoJ2NlbnRlcicpICYmICF0aGlzLnBsYWNlbWVudC5pbmNsdWRlcygnbWlkZGxlJyksXG4gICAgICAndHJhbnNsYXRlLW1pZGRsZS15JzogdGhpcy5wbGFjZW1lbnQuaW5jbHVkZXMoJ21pZGRsZScpICYmICF0aGlzLnBsYWNlbWVudC5pbmNsdWRlcygnY2VudGVyJyksXG4gICAgICAndHJhbnNsYXRlLW1pZGRsZSc6IHRoaXMucGxhY2VtZW50LmluY2x1ZGVzKCdtaWRkbGUnKSAmJiB0aGlzLnBsYWNlbWVudC5pbmNsdWRlcygnY2VudGVyJylcbiAgICB9O1xuICB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgdGhpcy5zdGF0ZVRvYXN0ZXJTdWJzY3JpYmUoKTtcbiAgfVxuXG4gIG5nQWZ0ZXJDb250ZW50Q2hlY2tlZCgpOiB2b2lkIHtcbiAgICB0aGlzLnRvYXN0cyA9IHRoaXMuY29udGVudFRvYXN0cztcbiAgfVxuXG4gIHB1YmxpYyBhZGRUb2FzdChcbiAgICB0b2FzdDogYW55LFxuICAgIHByb3BzOiBhbnksXG4gICAgb3B0aW9ucz86IHtcbiAgICAgIGluZGV4PzogbnVtYmVyO1xuICAgICAgaW5qZWN0b3I/OiBJbmplY3RvcjtcbiAgICAgIG5nTW9kdWxlUmVmPzogTmdNb2R1bGVSZWY8dW5rbm93bj47XG4gICAgICBwcm9qZWN0YWJsZU5vZGVzPzogTm9kZVtdW107XG4gICAgfVxuICApOiBDb21wb25lbnRSZWY8YW55PiB7XG4gICAgY29uc3QgY29tcG9uZW50UmVmOiBDb21wb25lbnRSZWY8YW55PiA9IHRoaXMudG9hc3Rlckhvc3Qudmlld0NvbnRhaW5lclJlZi5jcmVhdGVDb21wb25lbnQodG9hc3QsIG9wdGlvbnMpO1xuICAgIHRoaXMudG9hc3RzRHluYW1pYy5wdXNoKGNvbXBvbmVudFJlZik7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnRvYXN0c0R5bmFtaWMuaW5kZXhPZihjb21wb25lbnRSZWYpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BzKSkge1xuICAgICAgY29tcG9uZW50UmVmLmluc3RhbmNlW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgY29tcG9uZW50UmVmLmluc3RhbmNlWydwbGFjZW1lbnQnXSA9IHRoaXMucGxhY2VtZW50O1xuICAgIGNvbXBvbmVudFJlZi5pbnN0YW5jZVsnZHluYW1pYyddID0gdHJ1ZTtcbiAgICBjb21wb25lbnRSZWYuaW5zdGFuY2VbJ2luZGV4J10gPSBpbmRleDtcbiAgICBjb21wb25lbnRSZWYuaW5zdGFuY2VbJ3Zpc2libGUnXSA9IHRydWU7XG4gICAgY29tcG9uZW50UmVmLmluc3RhbmNlWyd2aXNpYmxlQ2hhbmdlJ10uZW1pdCh0cnVlKTtcbiAgICBjb21wb25lbnRSZWYuY2hhbmdlRGV0ZWN0b3JSZWY/LmRldGVjdENoYW5nZXMoKTtcbiAgICByZXR1cm4gY29tcG9uZW50UmVmO1xuICB9XG5cbiAgcHVibGljIHJlbW92ZVRvYXN0KHN0YXRlOiBJVG9hc3RlckFjdGlvbik6IHZvaWQge1xuICAgIHRoaXMudG9hc3RzRHluYW1pYz8uZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKHN0YXRlLnRvYXN0Py5keW5hbWljICYmIGl0ZW0uaW5zdGFuY2UgPT09IHN0YXRlLnRvYXN0KSB7XG4gICAgICAgIGl0ZW0uaW5zdGFuY2UudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICBpdGVtLmluc3RhbmNlWyd2aXNpYmxlQ2hhbmdlJ10uZW1pdChmYWxzZSk7XG4gICAgICAgIGl0ZW0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy50b2FzdHM/LmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgIGlmIChzdGF0ZS50b2FzdCAmJiBpdGVtLmVsZW1lbnQubmF0aXZlRWxlbWVudCA9PT0gc3RhdGUudG9hc3QuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudCkge1xuICAgICAgICBpZiAoIXN0YXRlLnRvYXN0LmR5bmFtaWMpIHtcbiAgICAgICAgICBzdGF0ZS50b2FzdC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGVUb2FzdGVyU3Vic2NyaWJlKCk6IHZvaWQge1xuICAgIHRoaXMudG9hc3RlclNlcnZpY2UudG9hc3RlclN0YXRlJC5waXBlKHRha2VVbnRpbERlc3Ryb3llZCh0aGlzLiNkZXN0cm95UmVmKSkuc3Vic2NyaWJlKChzdGF0ZSkgPT4ge1xuICAgICAgaWYgKHN0YXRlLnNob3cgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlVG9hc3Qoc3RhdGUpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnNob3cgPT09IHRydWUgJiYgc3RhdGUudG9hc3Q/LmR5bmFtaWMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvKiBlbXB0eSAqL1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCI8bmctdGVtcGxhdGUgY1RvYXN0ZXJIb3N0IC8+XG48bmctY29udGVudCBjVG9hc3Rlckhvc3QgLz5cbiJdfQ==